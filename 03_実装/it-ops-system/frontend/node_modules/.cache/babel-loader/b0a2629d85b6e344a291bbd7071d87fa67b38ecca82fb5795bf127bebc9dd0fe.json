{"ast":null,"code":"/**\r\n * WebSocketクライアント - リアルタイム通信用\r\n */\nclass WebSocketClient {\n  constructor(url = 'ws://localhost:3002/ws') {\n    this.socket = null;\n    this.url = void 0;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = 3000;\n    // ms\n    this.listeners = {};\n    this.url = url;\n  }\n\n  /**\r\n   * WebSocket接続を開始する\r\n   */\n  connect() {\n    if (this.socket) {\n      this.disconnect();\n    }\n    try {\n      console.log(`Connecting to WebSocket at ${this.url}`);\n      this.socket = new WebSocket(this.url);\n      this.socket.onopen = () => {\n        console.log('WebSocket connection established');\n        this.reconnectAttempts = 0;\n        this.emit('connected', {\n          timestamp: new Date().toISOString()\n        });\n      };\n      this.socket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.emit('message', data);\n\n          // 特定のタイプのメッセージに対するイベント発火\n          if (data.type) {\n            this.emit(data.type, data);\n          }\n        } catch (e) {\n          console.error('Failed to parse WebSocket message:', e);\n        }\n      };\n      this.socket.onclose = event => {\n        console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n        this.socket = null;\n        this.emit('disconnected', {\n          code: event.code,\n          reason: event.reason,\n          timestamp: new Date().toISOString()\n        });\n\n        // 再接続を試みる（接続が正常に切断された場合を除く）\n        if (event.code !== 1000 && event.code !== 1001) {\n          this.attemptReconnect();\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.emit('error', {\n          error,\n          timestamp: new Date().toISOString()\n        });\n      };\n    } catch (err) {\n      console.error('Failed to establish WebSocket connection:', err);\n      this.emit('error', {\n        error: err,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  /**\r\n   * WebSocket接続を再接続する\r\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Maximum reconnection attempts reached');\n      return;\n    }\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n\n    // 再接続の間隔を指数関数的に増加させる（バックオフ戦略）\n    const timeout = this.reconnectTimeout * Math.pow(1.5, this.reconnectAttempts - 1);\n    console.log(`Will try again in ${timeout}ms`);\n    setTimeout(() => {\n      this.connect();\n    }, timeout);\n  }\n\n  /**\r\n   * WebSocket接続を閉じる\r\n   */\n  disconnect() {\n    if (this.socket) {\n      this.socket.close(1000, 'Closed by client');\n      this.socket = null;\n    }\n  }\n\n  /**\r\n   * サーバーにメッセージを送信する\r\n   */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.error('Cannot send message: WebSocket is not connected');\n      return false;\n    }\n    try {\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\n      this.socket.send(message);\n      return true;\n    } catch (err) {\n      console.error('Failed to send message:', err);\n      return false;\n    }\n  }\n\n  /**\r\n   * イベントリスナーを登録する\r\n   */\n  on(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n\n  /**\r\n   * イベントリスナーを削除する\r\n   */\n  off(event, callback) {\n    if (!this.listeners[event]) return;\n    if (callback) {\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    } else {\n      delete this.listeners[event];\n    }\n  }\n\n  /**\r\n   * イベントを発火する\r\n   */\n  emit(event, data) {\n    if (!this.listeners[event]) return;\n    this.listeners[event].forEach(callback => {\n      try {\n        callback(data);\n      } catch (err) {\n        console.error(`Error in '${event}' event handler:`, err);\n      }\n    });\n  }\n\n  /**\r\n   * WebSocket接続の状態を取得する\r\n   */\n  get status() {\n    if (!this.socket) return 'CLOSED';\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING:\n        return 'CONNECTING';\n      case WebSocket.OPEN:\n        return 'OPEN';\n      case WebSocket.CLOSING:\n        return 'CLOSING';\n      case WebSocket.CLOSED:\n        return 'CLOSED';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n\n  /**\r\n   * WebSocket接続が開いているかどうかを確認する\r\n   */\n  get isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n}\n\n// シングルトンインスタンス\n// APIの健全性チェック用にフォールバックモードを実装\nclass WebSocketManager {\n  constructor() {\n    this.client = void 0;\n    this.usePolling = false;\n    this.pollingInterval = 10000;\n    // 10秒\n    this.pollingTimer = null;\n    this.client = new WebSocketClient();\n\n    // WebSocketが失敗した場合のフォールバック処理を設定\n    this.client.on('error', () => {\n      if (!this.usePolling) {\n        console.log('WebSocket connection failed, falling back to polling');\n        this.enablePolling();\n      }\n    });\n  }\n\n  // WebSocketクライアントを取得\n  getClient() {\n    return this.client;\n  }\n\n  // 接続を開始\n  connect() {\n    // すでにポーリングモードの場合は新しいWebSocket接続を試みない\n    if (this.usePolling) {\n      return;\n    }\n    this.client.connect();\n  }\n\n  // 接続を終了\n  disconnect() {\n    this.client.disconnect();\n    this.disablePolling();\n  }\n\n  // ポーリングモードを有効化\n  enablePolling() {\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer);\n    }\n    this.usePolling = true;\n    this.pollingTimer = setInterval(() => {\n      // 従来のAPIエンドポイントを使用してヘルスチェック\n      fetch('/api/health').then(response => {\n        if (response.ok) {\n          console.log('Health check successful via polling');\n        } else {\n          console.error('Health check failed via polling');\n        }\n      }).catch(err => {\n        console.error('Health check request failed:', err);\n      });\n    }, this.pollingInterval);\n  }\n\n  // ポーリングモードを無効化\n  disablePolling() {\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer);\n      this.pollingTimer = null;\n    }\n    this.usePolling = false;\n  }\n\n  // 接続状態を確認\n  get isConnected() {\n    return this.client.isConnected;\n  }\n\n  // WebSocketを使用するかポーリングを使用するかを確認\n  get isUsingPolling() {\n    return this.usePolling;\n  }\n}\nconst websocketManager = new WebSocketManager();\nexport default websocketManager.getClient();","map":{"version":3,"names":["WebSocketClient","constructor","url","socket","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","listeners","connect","disconnect","console","log","WebSocket","onopen","emit","timestamp","Date","toISOString","onmessage","event","data","JSON","parse","type","e","error","onclose","code","reason","attemptReconnect","onerror","err","timeout","Math","pow","setTimeout","close","send","readyState","OPEN","message","stringify","on","callback","push","off","filter","cb","forEach","status","CONNECTING","CLOSING","CLOSED","isConnected","WebSocketManager","client","usePolling","pollingInterval","pollingTimer","enablePolling","getClient","disablePolling","clearInterval","setInterval","fetch","then","response","ok","catch","isUsingPolling","websocketManager"],"sources":["E:/IT運用システム/03_実装/it-ops-system/frontend/src/services/websocket.ts"],"sourcesContent":["/**\r\n * WebSocketクライアント - リアルタイム通信用\r\n */\r\nclass WebSocketClient {\r\n  private socket: WebSocket | null = null;\r\n  private url: string;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout = 3000; // ms\r\n  private listeners: Record<string, Function[]> = {};\r\n  \r\n  constructor(url: string = 'ws://localhost:3002/ws') {\r\n    this.url = url;\r\n  }\r\n\r\n  /**\r\n   * WebSocket接続を開始する\r\n   */\r\n  connect(): void {\r\n    if (this.socket) {\r\n      this.disconnect();\r\n    }\r\n\r\n    try {\r\n      console.log(`Connecting to WebSocket at ${this.url}`);\r\n      this.socket = new WebSocket(this.url);\r\n      \r\n      this.socket.onopen = () => {\r\n        console.log('WebSocket connection established');\r\n        this.reconnectAttempts = 0;\r\n        this.emit('connected', { timestamp: new Date().toISOString() });\r\n      };\r\n      \r\n      this.socket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          this.emit('message', data);\r\n          \r\n          // 特定のタイプのメッセージに対するイベント発火\r\n          if (data.type) {\r\n            this.emit(data.type, data);\r\n          }\r\n        } catch (e) {\r\n          console.error('Failed to parse WebSocket message:', e);\r\n        }\r\n      };\r\n      \r\n      this.socket.onclose = (event) => {\r\n        console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\r\n        this.socket = null;\r\n        this.emit('disconnected', { \r\n          code: event.code, \r\n          reason: event.reason, \r\n          timestamp: new Date().toISOString() \r\n        });\r\n        \r\n        // 再接続を試みる（接続が正常に切断された場合を除く）\r\n        if (event.code !== 1000 && event.code !== 1001) {\r\n          this.attemptReconnect();\r\n        }\r\n      };\r\n      \r\n      this.socket.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        this.emit('error', { error, timestamp: new Date().toISOString() });\r\n      };\r\n    } catch (err) {\r\n      console.error('Failed to establish WebSocket connection:', err);\r\n      this.emit('error', { error: err, timestamp: new Date().toISOString() });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続を再接続する\r\n   */\r\n  private attemptReconnect(): void {\r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.log('Maximum reconnection attempts reached');\r\n      return;\r\n    }\r\n    \r\n    this.reconnectAttempts++;\r\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n    \r\n    // 再接続の間隔を指数関数的に増加させる（バックオフ戦略）\r\n    const timeout = this.reconnectTimeout * Math.pow(1.5, this.reconnectAttempts - 1);\r\n    console.log(`Will try again in ${timeout}ms`);\r\n    \r\n    setTimeout(() => {\r\n      this.connect();\r\n    }, timeout);\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続を閉じる\r\n   */\r\n  disconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.close(1000, 'Closed by client');\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * サーバーにメッセージを送信する\r\n   */\r\n  send(data: any): boolean {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      console.error('Cannot send message: WebSocket is not connected');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\r\n      this.socket.send(message);\r\n      return true;\r\n    } catch (err) {\r\n      console.error('Failed to send message:', err);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * イベントリスナーを登録する\r\n   */\r\n  on(event: string, callback: Function): void {\r\n    if (!this.listeners[event]) {\r\n      this.listeners[event] = [];\r\n    }\r\n    this.listeners[event].push(callback);\r\n  }\r\n  \r\n  /**\r\n   * イベントリスナーを削除する\r\n   */\r\n  off(event: string, callback?: Function): void {\r\n    if (!this.listeners[event]) return;\r\n    \r\n    if (callback) {\r\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\r\n    } else {\r\n      delete this.listeners[event];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * イベントを発火する\r\n   */\r\n  private emit(event: string, data: any): void {\r\n    if (!this.listeners[event]) return;\r\n    \r\n    this.listeners[event].forEach(callback => {\r\n      try {\r\n        callback(data);\r\n      } catch (err) {\r\n        console.error(`Error in '${event}' event handler:`, err);\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続の状態を取得する\r\n   */\r\n  get status(): string {\r\n    if (!this.socket) return 'CLOSED';\r\n    \r\n    switch (this.socket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return 'CONNECTING';\r\n      case WebSocket.OPEN:\r\n        return 'OPEN';\r\n      case WebSocket.CLOSING:\r\n        return 'CLOSING';\r\n      case WebSocket.CLOSED:\r\n        return 'CLOSED';\r\n      default:\r\n        return 'UNKNOWN';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続が開いているかどうかを確認する\r\n   */\r\n  get isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// シングルトンインスタンス\r\n// APIの健全性チェック用にフォールバックモードを実装\r\nclass WebSocketManager {\r\n  private client: WebSocketClient;\r\n  private usePolling: boolean = false;\r\n  private pollingInterval: number = 10000; // 10秒\r\n  private pollingTimer: NodeJS.Timeout | null = null;\r\n  \r\n  constructor() {\r\n    this.client = new WebSocketClient();\r\n    \r\n    // WebSocketが失敗した場合のフォールバック処理を設定\r\n    this.client.on('error', () => {\r\n      if (!this.usePolling) {\r\n        console.log('WebSocket connection failed, falling back to polling');\r\n        this.enablePolling();\r\n      }\r\n    });\r\n  }\r\n  \r\n  // WebSocketクライアントを取得\r\n  getClient(): WebSocketClient {\r\n    return this.client;\r\n  }\r\n  \r\n  // 接続を開始\r\n  connect(): void {\r\n    // すでにポーリングモードの場合は新しいWebSocket接続を試みない\r\n    if (this.usePolling) {\r\n      return;\r\n    }\r\n    \r\n    this.client.connect();\r\n  }\r\n  \r\n  // 接続を終了\r\n  disconnect(): void {\r\n    this.client.disconnect();\r\n    this.disablePolling();\r\n  }\r\n  \r\n  // ポーリングモードを有効化\r\n  private enablePolling(): void {\r\n    if (this.pollingTimer) {\r\n      clearInterval(this.pollingTimer);\r\n    }\r\n    \r\n    this.usePolling = true;\r\n    this.pollingTimer = setInterval(() => {\r\n      // 従来のAPIエンドポイントを使用してヘルスチェック\r\n      fetch('/api/health')\r\n        .then(response => {\r\n          if (response.ok) {\r\n            console.log('Health check successful via polling');\r\n          } else {\r\n            console.error('Health check failed via polling');\r\n          }\r\n        })\r\n        .catch(err => {\r\n          console.error('Health check request failed:', err);\r\n        });\r\n    }, this.pollingInterval);\r\n  }\r\n  \r\n  // ポーリングモードを無効化\r\n  private disablePolling(): void {\r\n    if (this.pollingTimer) {\r\n      clearInterval(this.pollingTimer);\r\n      this.pollingTimer = null;\r\n    }\r\n    this.usePolling = false;\r\n  }\r\n  \r\n  // 接続状態を確認\r\n  get isConnected(): boolean {\r\n    return this.client.isConnected;\r\n  }\r\n  \r\n  // WebSocketを使用するかポーリングを使用するかを確認\r\n  get isUsingPolling(): boolean {\r\n    return this.usePolling;\r\n  }\r\n}\r\n\r\nconst websocketManager = new WebSocketManager();\r\nexport default websocketManager.getClient();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}