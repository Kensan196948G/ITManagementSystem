{"ast":null,"code":"/**\r\n * WebSocketクライアント - リアルタイム通信用\r\n */\nclass WebSocketClient {\n  constructor(url = 'ws://localhost:3002/ws') {\n    this.socket = null;\n    this.url = void 0;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = 3000;\n    // ms\n    this.listeners = {};\n    // アドレスが変更された場合のフォールバック\n    if (process.env.NODE_ENV === 'development') {\n      // 開発環境では複数のフォールバックURLを試す\n      this.url = url;\n      // ウィンドウオブジェクトに現在のURLを保存して、ページ間で共有\n      if (typeof window !== 'undefined') {\n        window.__websocketUrl = this.url;\n      }\n    } else {\n      // 本番環境ではプロセス環境変数から取得\n      this.url = process.env.REACT_APP_WEBSOCKET_URL || url;\n    }\n    console.log(`WebSocket configured with URL: ${this.url}`);\n  }\n\n  /**\r\n   * WebSocket接続を開始する\r\n   * @param fallbackUrls 接続に失敗した場合に試すフォールバックURL\r\n   */\n  connect(fallbackUrls = []) {\n    if (this.socket) {\n      this.disconnect();\n    }\n    try {\n      console.log(`Connecting to WebSocket at ${this.url}`);\n\n      // WebSocketインスタンスを作成する前にURL検証\n      if (!this.url || !this.url.startsWith('ws')) {\n        throw new Error(`Invalid WebSocket URL: ${this.url}`);\n      }\n      this.socket = new WebSocket(this.url);\n      this.socket.onopen = () => {\n        console.log('WebSocket connection established');\n        this.reconnectAttempts = 0;\n        this.emit('connected', {\n          timestamp: new Date().toISOString()\n        });\n      };\n      this.socket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.emit('message', data);\n\n          // 特定のタイプのメッセージに対するイベント発火\n          if (data.type) {\n            this.emit(data.type, data);\n          }\n        } catch (e) {\n          console.error('Failed to parse WebSocket message:', e);\n        }\n      };\n      this.socket.onclose = event => {\n        console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n        this.socket = null;\n        this.emit('disconnected', {\n          code: event.code,\n          reason: event.reason,\n          timestamp: new Date().toISOString()\n        });\n\n        // 再接続を試みる（接続が正常に切断された場合を除く）\n        if (event.code !== 1000 && event.code !== 1001) {\n          this.attemptReconnect();\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.emit('error', {\n          error,\n          timestamp: new Date().toISOString()\n        });\n\n        // フォールバックURLがあれば次のURLを試す\n        if (fallbackUrls.length > 0) {\n          console.log(`Trying fallback WebSocket URL: ${fallbackUrls[0]}`);\n          this.url = fallbackUrls[0];\n          setTimeout(() => {\n            this.connect(fallbackUrls.slice(1));\n          }, 1000); // 1秒待ってから次のURLを試す\n        }\n      };\n    } catch (err) {\n      console.error('Failed to establish WebSocket connection:', err);\n      this.emit('error', {\n        error: err,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  /**\r\n   * WebSocket接続を再接続する\r\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Maximum reconnection attempts reached');\n      return;\n    }\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n\n    // 再接続の間隔を指数関数的に増加させる（バックオフ戦略）\n    const timeout = this.reconnectTimeout * Math.pow(1.5, this.reconnectAttempts - 1);\n    console.log(`Will try again in ${timeout}ms`);\n    setTimeout(() => {\n      this.connect();\n    }, timeout);\n  }\n\n  /**\r\n   * WebSocket接続を閉じる\r\n   */\n  disconnect() {\n    if (this.socket) {\n      this.socket.close(1000, 'Closed by client');\n      this.socket = null;\n    }\n  }\n\n  /**\r\n   * サーバーにメッセージを送信する\r\n   */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.error('Cannot send message: WebSocket is not connected');\n      return false;\n    }\n    try {\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\n      this.socket.send(message);\n      return true;\n    } catch (err) {\n      console.error('Failed to send message:', err);\n      return false;\n    }\n  }\n\n  /**\r\n   * イベントリスナーを登録する\r\n   */\n  on(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n\n  /**\r\n   * イベントリスナーを削除する\r\n   */\n  off(event, callback) {\n    if (!this.listeners[event]) return;\n    if (callback) {\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    } else {\n      delete this.listeners[event];\n    }\n  }\n\n  /**\r\n   * イベントを発火する\r\n   */\n  emit(event, data) {\n    if (!this.listeners[event]) return;\n    this.listeners[event].forEach(callback => {\n      try {\n        callback(data);\n      } catch (err) {\n        console.error(`Error in '${event}' event handler:`, err);\n      }\n    });\n  }\n\n  /**\r\n   * WebSocket接続の状態を取得する\r\n   */\n  get status() {\n    if (!this.socket) return 'CLOSED';\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING:\n        return 'CONNECTING';\n      case WebSocket.OPEN:\n        return 'OPEN';\n      case WebSocket.CLOSING:\n        return 'CLOSING';\n      case WebSocket.CLOSED:\n        return 'CLOSED';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n\n  /**\r\n   * WebSocket接続が開いているかどうかを確認する\r\n   */\n  get isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n}\n\n// シングルトンインスタンス\n// APIの健全性チェック用にフォールバックモードを実装\nclass WebSocketManager {\n  constructor() {\n    this.client = void 0;\n    this.usePolling = false;\n    this.pollingInterval = 10000;\n    // 10秒\n    this.pollingTimer = null;\n    this.fallbackUrls = ['ws://localhost:3002/ws',\n    // 標準的なWebSocketエンドポイント\n    'wss://localhost:3002/ws',\n    // セキュアWebSocketも試す\n    'ws://127.0.0.1:3002/ws',\n    // IPアドレスを使用\n    'ws://localhost:3001/ws' // 代替ポート\n    ];\n    // 最初に標準のURLで接続を試行するWebSocketクライアントを作成\n    this.client = new WebSocketClient();\n\n    // WebSocketが失敗した場合のフォールバック処理を設定\n    this.client.on('error', () => {\n      if (!this.usePolling) {\n        console.log('WebSocket connection failed, trying alternative URLs');\n\n        // 現在のURLをリストから除外\n        const currentUrl = this.client.url;\n        const remainingUrls = this.fallbackUrls.filter(url => url !== currentUrl);\n        if (remainingUrls.length > 0) {\n          // 残りのURLがあれば試す\n          this.client.connect(remainingUrls);\n        } else {\n          // すべてのURLが失敗した場合はポーリングにフォールバック\n          console.log('All WebSocket URLs failed, falling back to polling');\n          this.enablePolling();\n        }\n      }\n    });\n  }\n\n  // WebSocketクライアントを取得\n  getClient() {\n    return this.client;\n  }\n\n  // 接続を開始\n  connect() {\n    // すでにポーリングモードの場合は新しいWebSocket接続を試みない\n    if (this.usePolling) {\n      return;\n    }\n\n    // 最初に標準のURLで試し、失敗した場合はフォールバックURLを試す\n    this.client.connect(this.fallbackUrls.filter(url => url !== this.client.url));\n  }\n\n  // 接続を終了\n  disconnect() {\n    this.client.disconnect();\n    this.disablePolling();\n  }\n\n  // ポーリングモードを有効化\n  enablePolling() {\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer);\n    }\n    this.usePolling = true;\n    this.pollingTimer = setInterval(() => {\n      // 従来のAPIエンドポイントを使用してヘルスチェック\n      fetch('/api/health').then(response => {\n        if (response.ok) {\n          console.log('Health check successful via polling');\n        } else {\n          console.error('Health check failed via polling');\n        }\n      }).catch(err => {\n        console.error('Health check request failed:', err);\n      });\n    }, this.pollingInterval);\n  }\n\n  // ポーリングモードを無効化\n  disablePolling() {\n    if (this.pollingTimer) {\n      clearInterval(this.pollingTimer);\n      this.pollingTimer = null;\n    }\n    this.usePolling = false;\n  }\n\n  // 接続状態を確認\n  get isConnected() {\n    return this.client.isConnected;\n  }\n\n  // WebSocketを使用するかポーリングを使用するかを確認\n  get isUsingPolling() {\n    return this.usePolling;\n  }\n}\nconst websocketManager = new WebSocketManager();\nexport default websocketManager.getClient();","map":{"version":3,"names":["WebSocketClient","constructor","url","socket","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","listeners","process","env","NODE_ENV","window","__websocketUrl","REACT_APP_WEBSOCKET_URL","console","log","connect","fallbackUrls","disconnect","startsWith","Error","WebSocket","onopen","emit","timestamp","Date","toISOString","onmessage","event","data","JSON","parse","type","e","error","onclose","code","reason","attemptReconnect","onerror","length","setTimeout","slice","err","timeout","Math","pow","close","send","readyState","OPEN","message","stringify","on","callback","push","off","filter","cb","forEach","status","CONNECTING","CLOSING","CLOSED","isConnected","WebSocketManager","client","usePolling","pollingInterval","pollingTimer","currentUrl","remainingUrls","enablePolling","getClient","disablePolling","clearInterval","setInterval","fetch","then","response","ok","catch","isUsingPolling","websocketManager"],"sources":["E:/IT運用システム/03_実装/it-ops-system/frontend/src/services/websocket.ts"],"sourcesContent":["/**\r\n * WebSocketクライアント - リアルタイム通信用\r\n */\r\nclass WebSocketClient {\r\n  private socket: WebSocket | null = null;\r\n  private url: string;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout = 3000; // ms\r\n  private listeners: Record<string, Function[]> = {};\r\n  \r\n  constructor(url: string = 'ws://localhost:3002/ws') {\r\n    // アドレスが変更された場合のフォールバック\r\n    if (process.env.NODE_ENV === 'development') {\r\n      // 開発環境では複数のフォールバックURLを試す\r\n      this.url = url;\r\n      // ウィンドウオブジェクトに現在のURLを保存して、ページ間で共有\r\n      if (typeof window !== 'undefined') {\r\n        (window as any).__websocketUrl = this.url;\r\n      }\r\n    } else {\r\n      // 本番環境ではプロセス環境変数から取得\r\n      this.url = process.env.REACT_APP_WEBSOCKET_URL || url;\r\n    }\r\n    \r\n    console.log(`WebSocket configured with URL: ${this.url}`);\r\n  }\r\n\r\n  /**\r\n   * WebSocket接続を開始する\r\n   * @param fallbackUrls 接続に失敗した場合に試すフォールバックURL\r\n   */\r\n  connect(fallbackUrls: string[] = []): void {\r\n    if (this.socket) {\r\n      this.disconnect();\r\n    }\r\n\r\n    try {\r\n      console.log(`Connecting to WebSocket at ${this.url}`);\r\n      \r\n      // WebSocketインスタンスを作成する前にURL検証\r\n      if (!this.url || !this.url.startsWith('ws')) {\r\n        throw new Error(`Invalid WebSocket URL: ${this.url}`);\r\n      }\r\n      \r\n      this.socket = new WebSocket(this.url);\r\n      \r\n      this.socket.onopen = () => {\r\n        console.log('WebSocket connection established');\r\n        this.reconnectAttempts = 0;\r\n        this.emit('connected', { timestamp: new Date().toISOString() });\r\n      };\r\n      \r\n      this.socket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          this.emit('message', data);\r\n          \r\n          // 特定のタイプのメッセージに対するイベント発火\r\n          if (data.type) {\r\n            this.emit(data.type, data);\r\n          }\r\n        } catch (e) {\r\n          console.error('Failed to parse WebSocket message:', e);\r\n        }\r\n      };\r\n      \r\n      this.socket.onclose = (event) => {\r\n        console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\r\n        this.socket = null;\r\n        this.emit('disconnected', { \r\n          code: event.code, \r\n          reason: event.reason, \r\n          timestamp: new Date().toISOString() \r\n        });\r\n        \r\n        // 再接続を試みる（接続が正常に切断された場合を除く）\r\n        if (event.code !== 1000 && event.code !== 1001) {\r\n          this.attemptReconnect();\r\n        }\r\n      };\r\n      \r\n      this.socket.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        this.emit('error', { error, timestamp: new Date().toISOString() });\r\n        \r\n        // フォールバックURLがあれば次のURLを試す\r\n        if (fallbackUrls.length > 0) {\r\n          console.log(`Trying fallback WebSocket URL: ${fallbackUrls[0]}`);\r\n          this.url = fallbackUrls[0];\r\n          setTimeout(() => {\r\n            this.connect(fallbackUrls.slice(1));\r\n          }, 1000); // 1秒待ってから次のURLを試す\r\n        }\r\n      };\r\n    } catch (err) {\r\n      console.error('Failed to establish WebSocket connection:', err);\r\n      this.emit('error', { error: err, timestamp: new Date().toISOString() });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続を再接続する\r\n   */\r\n  private attemptReconnect(): void {\r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.log('Maximum reconnection attempts reached');\r\n      return;\r\n    }\r\n    \r\n    this.reconnectAttempts++;\r\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n    \r\n    // 再接続の間隔を指数関数的に増加させる（バックオフ戦略）\r\n    const timeout = this.reconnectTimeout * Math.pow(1.5, this.reconnectAttempts - 1);\r\n    console.log(`Will try again in ${timeout}ms`);\r\n    \r\n    setTimeout(() => {\r\n      this.connect();\r\n    }, timeout);\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続を閉じる\r\n   */\r\n  disconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.close(1000, 'Closed by client');\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * サーバーにメッセージを送信する\r\n   */\r\n  send(data: any): boolean {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      console.error('Cannot send message: WebSocket is not connected');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\r\n      this.socket.send(message);\r\n      return true;\r\n    } catch (err) {\r\n      console.error('Failed to send message:', err);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * イベントリスナーを登録する\r\n   */\r\n  on(event: string, callback: Function): void {\r\n    if (!this.listeners[event]) {\r\n      this.listeners[event] = [];\r\n    }\r\n    this.listeners[event].push(callback);\r\n  }\r\n  \r\n  /**\r\n   * イベントリスナーを削除する\r\n   */\r\n  off(event: string, callback?: Function): void {\r\n    if (!this.listeners[event]) return;\r\n    \r\n    if (callback) {\r\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\r\n    } else {\r\n      delete this.listeners[event];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * イベントを発火する\r\n   */\r\n  private emit(event: string, data: any): void {\r\n    if (!this.listeners[event]) return;\r\n    \r\n    this.listeners[event].forEach(callback => {\r\n      try {\r\n        callback(data);\r\n      } catch (err) {\r\n        console.error(`Error in '${event}' event handler:`, err);\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続の状態を取得する\r\n   */\r\n  get status(): string {\r\n    if (!this.socket) return 'CLOSED';\r\n    \r\n    switch (this.socket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return 'CONNECTING';\r\n      case WebSocket.OPEN:\r\n        return 'OPEN';\r\n      case WebSocket.CLOSING:\r\n        return 'CLOSING';\r\n      case WebSocket.CLOSED:\r\n        return 'CLOSED';\r\n      default:\r\n        return 'UNKNOWN';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続が開いているかどうかを確認する\r\n   */\r\n  get isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// シングルトンインスタンス\r\n// APIの健全性チェック用にフォールバックモードを実装\r\nclass WebSocketManager {\r\n  private client: WebSocketClient;\r\n  private usePolling: boolean = false;\r\n  private pollingInterval: number = 10000; // 10秒\r\n  private pollingTimer: NodeJS.Timeout | null = null;\r\n  private fallbackUrls: string[] = [\r\n    'ws://localhost:3002/ws',   // 標準的なWebSocketエンドポイント\r\n    'wss://localhost:3002/ws',  // セキュアWebSocketも試す\r\n    'ws://127.0.0.1:3002/ws',   // IPアドレスを使用\r\n    'ws://localhost:3001/ws',   // 代替ポート\r\n  ];\r\n  \r\n  constructor() {\r\n    // 最初に標準のURLで接続を試行するWebSocketクライアントを作成\r\n    this.client = new WebSocketClient();\r\n    \r\n    // WebSocketが失敗した場合のフォールバック処理を設定\r\n    this.client.on('error', () => {\r\n      if (!this.usePolling) {\r\n        console.log('WebSocket connection failed, trying alternative URLs');\r\n        \r\n        // 現在のURLをリストから除外\r\n        const currentUrl = this.client.url;\r\n        const remainingUrls = this.fallbackUrls.filter(url => url !== currentUrl);\r\n        \r\n        if (remainingUrls.length > 0) {\r\n          // 残りのURLがあれば試す\r\n          this.client.connect(remainingUrls);\r\n        } else {\r\n          // すべてのURLが失敗した場合はポーリングにフォールバック\r\n          console.log('All WebSocket URLs failed, falling back to polling');\r\n          this.enablePolling();\r\n        }\r\n      }\r\n    });\r\n  }\r\n  \r\n  // WebSocketクライアントを取得\r\n  getClient(): WebSocketClient {\r\n    return this.client;\r\n  }\r\n  \r\n  // 接続を開始\r\n  connect(): void {\r\n    // すでにポーリングモードの場合は新しいWebSocket接続を試みない\r\n    if (this.usePolling) {\r\n      return;\r\n    }\r\n    \r\n    // 最初に標準のURLで試し、失敗した場合はフォールバックURLを試す\r\n    this.client.connect(this.fallbackUrls.filter(url => url !== this.client.url));\r\n  }\r\n  \r\n  // 接続を終了\r\n  disconnect(): void {\r\n    this.client.disconnect();\r\n    this.disablePolling();\r\n  }\r\n  \r\n  // ポーリングモードを有効化\r\n  private enablePolling(): void {\r\n    if (this.pollingTimer) {\r\n      clearInterval(this.pollingTimer);\r\n    }\r\n    \r\n    this.usePolling = true;\r\n    this.pollingTimer = setInterval(() => {\r\n      // 従来のAPIエンドポイントを使用してヘルスチェック\r\n      fetch('/api/health')\r\n        .then(response => {\r\n          if (response.ok) {\r\n            console.log('Health check successful via polling');\r\n          } else {\r\n            console.error('Health check failed via polling');\r\n          }\r\n        })\r\n        .catch(err => {\r\n          console.error('Health check request failed:', err);\r\n        });\r\n    }, this.pollingInterval);\r\n  }\r\n  \r\n  // ポーリングモードを無効化\r\n  private disablePolling(): void {\r\n    if (this.pollingTimer) {\r\n      clearInterval(this.pollingTimer);\r\n      this.pollingTimer = null;\r\n    }\r\n    this.usePolling = false;\r\n  }\r\n  \r\n  // 接続状態を確認\r\n  get isConnected(): boolean {\r\n    return this.client.isConnected;\r\n  }\r\n  \r\n  // WebSocketを使用するかポーリングを使用するかを確認\r\n  get isUsingPolling(): boolean {\r\n    return this.usePolling;\r\n  }\r\n}\r\n\r\nconst websocketManager = new WebSocketManager();\r\nexport default websocketManager.getClient();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}