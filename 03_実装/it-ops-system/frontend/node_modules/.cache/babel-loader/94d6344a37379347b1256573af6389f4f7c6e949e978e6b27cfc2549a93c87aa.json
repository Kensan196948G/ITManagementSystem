{"ast":null,"code":"/**\r\n * WebSocketクライアント - リアルタイム通信用\r\n */\nclass WebSocketClient {\n  constructor(url = 'ws://localhost:3002/ws') {\n    this.socket = null;\n    this.url = void 0;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = 3000;\n    // ms\n    this.listeners = {};\n    this.url = url;\n  }\n\n  /**\r\n   * WebSocket接続を開始する\r\n   */\n  connect() {\n    if (this.socket) {\n      this.disconnect();\n    }\n    try {\n      console.log(`Connecting to WebSocket at ${this.url}`);\n      this.socket = new WebSocket(this.url);\n      this.socket.onopen = () => {\n        console.log('WebSocket connection established');\n        this.reconnectAttempts = 0;\n        this.emit('connected', {\n          timestamp: new Date().toISOString()\n        });\n      };\n      this.socket.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          this.emit('message', data);\n\n          // 特定のタイプのメッセージに対するイベント発火\n          if (data.type) {\n            this.emit(data.type, data);\n          }\n        } catch (e) {\n          console.error('Failed to parse WebSocket message:', e);\n        }\n      };\n      this.socket.onclose = event => {\n        console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n        this.socket = null;\n        this.emit('disconnected', {\n          code: event.code,\n          reason: event.reason,\n          timestamp: new Date().toISOString()\n        });\n\n        // 再接続を試みる（接続が正常に切断された場合を除く）\n        if (event.code !== 1000 && event.code !== 1001) {\n          this.attemptReconnect();\n        }\n      };\n      this.socket.onerror = error => {\n        console.error('WebSocket error:', error);\n        this.emit('error', {\n          error,\n          timestamp: new Date().toISOString()\n        });\n      };\n    } catch (err) {\n      console.error('Failed to establish WebSocket connection:', err);\n      this.emit('error', {\n        error: err,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  /**\r\n   * WebSocket接続を再接続する\r\n   */\n  attemptReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('Maximum reconnection attempts reached');\n      return;\n    }\n    this.reconnectAttempts++;\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n    setTimeout(() => {\n      this.connect();\n    }, this.reconnectTimeout);\n  }\n\n  /**\r\n   * WebSocket接続を閉じる\r\n   */\n  disconnect() {\n    if (this.socket) {\n      this.socket.close(1000, 'Closed by client');\n      this.socket = null;\n    }\n  }\n\n  /**\r\n   * サーバーにメッセージを送信する\r\n   */\n  send(data) {\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\n      console.error('Cannot send message: WebSocket is not connected');\n      return false;\n    }\n    try {\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\n      this.socket.send(message);\n      return true;\n    } catch (err) {\n      console.error('Failed to send message:', err);\n      return false;\n    }\n  }\n\n  /**\r\n   * イベントリスナーを登録する\r\n   */\n  on(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n\n  /**\r\n   * イベントリスナーを削除する\r\n   */\n  off(event, callback) {\n    if (!this.listeners[event]) return;\n    if (callback) {\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\n    } else {\n      delete this.listeners[event];\n    }\n  }\n\n  /**\r\n   * イベントを発火する\r\n   */\n  emit(event, data) {\n    if (!this.listeners[event]) return;\n    this.listeners[event].forEach(callback => {\n      try {\n        callback(data);\n      } catch (err) {\n        console.error(`Error in '${event}' event handler:`, err);\n      }\n    });\n  }\n\n  /**\r\n   * WebSocket接続の状態を取得する\r\n   */\n  get status() {\n    if (!this.socket) return 'CLOSED';\n    switch (this.socket.readyState) {\n      case WebSocket.CONNECTING:\n        return 'CONNECTING';\n      case WebSocket.OPEN:\n        return 'OPEN';\n      case WebSocket.CLOSING:\n        return 'CLOSING';\n      case WebSocket.CLOSED:\n        return 'CLOSED';\n      default:\n        return 'UNKNOWN';\n    }\n  }\n\n  /**\r\n   * WebSocket接続が開いているかどうかを確認する\r\n   */\n  get isConnected() {\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\n  }\n}\n\n// シングルトンインスタンス\nconst websocket = new WebSocketClient();\nexport default websocket;","map":{"version":3,"names":["WebSocketClient","constructor","url","socket","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","listeners","connect","disconnect","console","log","WebSocket","onopen","emit","timestamp","Date","toISOString","onmessage","event","data","JSON","parse","type","e","error","onclose","code","reason","attemptReconnect","onerror","err","setTimeout","close","send","readyState","OPEN","message","stringify","on","callback","push","off","filter","cb","forEach","status","CONNECTING","CLOSING","CLOSED","isConnected","websocket"],"sources":["E:/IT運用システム/03_実装/it-ops-system/frontend/src/services/websocket.ts"],"sourcesContent":["/**\r\n * WebSocketクライアント - リアルタイム通信用\r\n */\r\nclass WebSocketClient {\r\n  private socket: WebSocket | null = null;\r\n  private url: string;\r\n  private reconnectAttempts = 0;\r\n  private maxReconnectAttempts = 5;\r\n  private reconnectTimeout = 3000; // ms\r\n  private listeners: Record<string, Function[]> = {};\r\n  \r\n  constructor(url: string = 'ws://localhost:3002/ws') {\r\n    this.url = url;\r\n  }\r\n\r\n  /**\r\n   * WebSocket接続を開始する\r\n   */\r\n  connect(): void {\r\n    if (this.socket) {\r\n      this.disconnect();\r\n    }\r\n\r\n    try {\r\n      console.log(`Connecting to WebSocket at ${this.url}`);\r\n      this.socket = new WebSocket(this.url);\r\n      \r\n      this.socket.onopen = () => {\r\n        console.log('WebSocket connection established');\r\n        this.reconnectAttempts = 0;\r\n        this.emit('connected', { timestamp: new Date().toISOString() });\r\n      };\r\n      \r\n      this.socket.onmessage = (event) => {\r\n        try {\r\n          const data = JSON.parse(event.data);\r\n          this.emit('message', data);\r\n          \r\n          // 特定のタイプのメッセージに対するイベント発火\r\n          if (data.type) {\r\n            this.emit(data.type, data);\r\n          }\r\n        } catch (e) {\r\n          console.error('Failed to parse WebSocket message:', e);\r\n        }\r\n      };\r\n      \r\n      this.socket.onclose = (event) => {\r\n        console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\r\n        this.socket = null;\r\n        this.emit('disconnected', { \r\n          code: event.code, \r\n          reason: event.reason, \r\n          timestamp: new Date().toISOString() \r\n        });\r\n        \r\n        // 再接続を試みる（接続が正常に切断された場合を除く）\r\n        if (event.code !== 1000 && event.code !== 1001) {\r\n          this.attemptReconnect();\r\n        }\r\n      };\r\n      \r\n      this.socket.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        this.emit('error', { error, timestamp: new Date().toISOString() });\r\n      };\r\n    } catch (err) {\r\n      console.error('Failed to establish WebSocket connection:', err);\r\n      this.emit('error', { error: err, timestamp: new Date().toISOString() });\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続を再接続する\r\n   */\r\n  private attemptReconnect(): void {\r\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n      console.log('Maximum reconnection attempts reached');\r\n      return;\r\n    }\r\n    \r\n    this.reconnectAttempts++;\r\n    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\r\n    \r\n    setTimeout(() => {\r\n      this.connect();\r\n    }, this.reconnectTimeout);\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続を閉じる\r\n   */\r\n  disconnect(): void {\r\n    if (this.socket) {\r\n      this.socket.close(1000, 'Closed by client');\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * サーバーにメッセージを送信する\r\n   */\r\n  send(data: any): boolean {\r\n    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {\r\n      console.error('Cannot send message: WebSocket is not connected');\r\n      return false;\r\n    }\r\n    \r\n    try {\r\n      const message = typeof data === 'string' ? data : JSON.stringify(data);\r\n      this.socket.send(message);\r\n      return true;\r\n    } catch (err) {\r\n      console.error('Failed to send message:', err);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * イベントリスナーを登録する\r\n   */\r\n  on(event: string, callback: Function): void {\r\n    if (!this.listeners[event]) {\r\n      this.listeners[event] = [];\r\n    }\r\n    this.listeners[event].push(callback);\r\n  }\r\n  \r\n  /**\r\n   * イベントリスナーを削除する\r\n   */\r\n  off(event: string, callback?: Function): void {\r\n    if (!this.listeners[event]) return;\r\n    \r\n    if (callback) {\r\n      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);\r\n    } else {\r\n      delete this.listeners[event];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * イベントを発火する\r\n   */\r\n  private emit(event: string, data: any): void {\r\n    if (!this.listeners[event]) return;\r\n    \r\n    this.listeners[event].forEach(callback => {\r\n      try {\r\n        callback(data);\r\n      } catch (err) {\r\n        console.error(`Error in '${event}' event handler:`, err);\r\n      }\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続の状態を取得する\r\n   */\r\n  get status(): string {\r\n    if (!this.socket) return 'CLOSED';\r\n    \r\n    switch (this.socket.readyState) {\r\n      case WebSocket.CONNECTING:\r\n        return 'CONNECTING';\r\n      case WebSocket.OPEN:\r\n        return 'OPEN';\r\n      case WebSocket.CLOSING:\r\n        return 'CLOSING';\r\n      case WebSocket.CLOSED:\r\n        return 'CLOSED';\r\n      default:\r\n        return 'UNKNOWN';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * WebSocket接続が開いているかどうかを確認する\r\n   */\r\n  get isConnected(): boolean {\r\n    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;\r\n  }\r\n}\r\n\r\n// シングルトンインスタンス\r\nconst websocket = new WebSocketClient();\r\n\r\nexport default websocket;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}